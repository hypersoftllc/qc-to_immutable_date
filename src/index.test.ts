
import { ImmutableDate } from 'qc-immutable_date';

import { toImmutableDate, toImmutableDateOrNull } from './index';

describe('qc-to_immutable_date', () => {

  describe('`toImmutableDate`', () => {

    it('should be a function', () => {
      expect(typeof toImmutableDate).toBe('function');
    });

    it('called with no arguments should return `undefined`', () => {
      expect(toImmutableDate()).toBeUndefined();
    });

    it('called with `arguments` should return input value', function () {
      expect(toImmutableDate(arguments)).toBe(arguments);
    });

    it('called with `undefined` input should return default value', () => {
      let input = undefined;

      expect(toImmutableDate(input)).toBe(input);
      expect(toImmutableDate(input, null)).toBeNull();
      expect(toImmutableDate(input, { def: null })).toBeNull();
      expect(toImmutableDate(input, undefined)).toBe(input);
      expect(toImmutableDate(input, { def: undefined })).toBe(input);
    });

    it('called with `null` input should return default value', () => {
      let input = null;

      expect(toImmutableDate(input)).toBeNull();
      expect(toImmutableDate(input, { def: null })).toBeNull();
      expect(toImmutableDate(input, { def: undefined })).toBeNull();
    });

    it('called with `NaN` should return default value', () => {
      let input = NaN;

      expect(toImmutableDate(input)).toEqual(NaN);
      expect(toImmutableDate(input, null)).toBeNull();
      expect(toImmutableDate(input, { def: null })).toBeNull();
      expect(toImmutableDate(input, undefined)).toEqual(NaN);
      expect(toImmutableDate(input, { def: undefined })).toEqual(NaN);
    });

    it('called with `false` input should return default value', () => {
      let input = false;
      
      expect(toImmutableDate(input)).toBe(input);
      expect(toImmutableDate(input, null)).toBeNull();
      expect(toImmutableDate(input, { def: null })).toBeNull();
      expect(toImmutableDate(input, undefined)).toBe(input);
      expect(toImmutableDate(input, { def: undefined })).toBe(input);
    });

    it('called with `true` input should return default value', () => {
      let input = true;
      
      expect(toImmutableDate(input)).toBe(input);
      expect(toImmutableDate(input, null)).toBeNull();
      expect(toImmutableDate(input, { def: null })).toBeNull();
      expect(toImmutableDate(input, undefined)).toBe(input);
      expect(toImmutableDate(input, { def: undefined })).toBe(input);
    });

    it('called with `-Infinity` should return default value', () => {
      let input = -Infinity;
      
      expect(toImmutableDate(input)).toBe(input);
      expect(toImmutableDate(input, null)).toBeNull();
      expect(toImmutableDate(input, { def: null })).toBeNull();
      expect(toImmutableDate(input, undefined)).toBe(input);
      expect(toImmutableDate(input, { def: undefined })).toBe(input);
    });

    it('called with `Infinity` should return default value', () => {
      let input = Infinity;
      
      expect(toImmutableDate(input)).toBe(input);
      expect(toImmutableDate(input, null)).toBeNull();
      expect(toImmutableDate(input, { def: null })).toBeNull();
      expect(toImmutableDate(input, undefined)).toBe(input);
      expect(toImmutableDate(input, { def: undefined })).toBe(input);
    });

    it('called with empty string input should return default value', () => {
      let input = '';
      
      expect(toImmutableDate(input)).toBe(input);
      expect(toImmutableDate(input, null)).toBeNull();
      expect(toImmutableDate(input, { def: null })).toBeNull();
      expect(toImmutableDate(input, undefined)).toBe(input);
      expect(toImmutableDate(input, { def: undefined })).toBe(input);
    });

    it('called with inconvertible input should return default value', function () {
      let def: any;

      def = arguments;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = [];
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = ['non-empty'];
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = false;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = true;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = new Date();
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = new Error('Help!');
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = function () {};
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = 123;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = 0;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = -123;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = Number.MAX_VALUE;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = Number.MIN_VALUE;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = Number.MAX_SAFE_INTEGER;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = Number.MIN_SAFE_INTEGER;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = {};
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = { prop: 'non-empty' };
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);


      def = /def/;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = '';
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = 'not empty';
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = null;
      expect(toImmutableDate(arguments, def)).toBe(def);
      expect(toImmutableDate(arguments, { def })).toBe(def);
      expect(toImmutableDate([], def)).toBe(def);
      expect(toImmutableDate([], { def })).toBe(def);
      expect(toImmutableDate(['not empty'], def)).toBe(def);
      expect(toImmutableDate(['not empty'], { def })).toBe(def);
      expect(toImmutableDate(true, def)).toBe(def);
      expect(toImmutableDate(true, { def })).toBe(def);
      expect(toImmutableDate(false, def)).toBe(def);
      expect(toImmutableDate(false, { def })).toBe(def);
      expect(toImmutableDate(new Error('Help!'), def)).toBe(def);
      expect(toImmutableDate(new Error('Help!'), { def })).toBe(def);
      expect(toImmutableDate(function () {}, def)).toBe(def);
      expect(toImmutableDate(function () {}, { def })).toBe(def);
      expect(toImmutableDate(Infinity, def)).toBe(def);
      expect(toImmutableDate(Infinity, { def })).toBe(def);
      expect(toImmutableDate(-Infinity, def)).toBe(def);
      expect(toImmutableDate(-Infinity, { def })).toBe(def);
      expect(toImmutableDate(NaN, def)).toBe(def);
      expect(toImmutableDate(NaN, { def })).toBe(def);
      expect(toImmutableDate(Number.NaN, def)).toBe(def);
      expect(toImmutableDate(Number.NaN, { def })).toBe(def);
      expect(toImmutableDate({}, def)).toBe(def);
      expect(toImmutableDate({}, { def })).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toBe(def);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toBe(def);
      expect(toImmutableDate(/regexp/, def)).toBe(def);
      expect(toImmutableDate(/regexp/, { def })).toBe(def);
      expect(toImmutableDate('', def)).toBe(def);
      expect(toImmutableDate('', { def })).toBe(def);
      expect(toImmutableDate('not empty', def)).toBe(def);
      expect(toImmutableDate('not empty', { def })).toBe(def);
      expect(toImmutableDate(null, def)).toBe(def);
      expect(toImmutableDate(null, { def })).toBe(def);
      expect(toImmutableDate(undefined, def)).toBe(def);
      expect(toImmutableDate(undefined, { def })).toBe(def);

      def = NaN;
      expect(toImmutableDate(arguments, def)).toEqual(NaN);
      expect(toImmutableDate(arguments, { def })).toEqual(NaN);
      expect(toImmutableDate([], def)).toEqual(NaN);
      expect(toImmutableDate([], { def })).toEqual(NaN);
      expect(toImmutableDate(['not empty'], def)).toEqual(NaN);
      expect(toImmutableDate(['not empty'], { def })).toEqual(NaN);
      expect(toImmutableDate(true, def)).toEqual(NaN);
      expect(toImmutableDate(true, { def })).toEqual(NaN);
      expect(toImmutableDate(false, def)).toEqual(NaN);
      expect(toImmutableDate(false, { def })).toEqual(NaN);
      expect(toImmutableDate(new Error('Help!'), def)).toEqual(NaN);
      expect(toImmutableDate(new Error('Help!'), { def })).toEqual(NaN);
      expect(toImmutableDate(function () {}, def)).toEqual(NaN);
      expect(toImmutableDate(function () {}, { def })).toEqual(NaN);
      expect(toImmutableDate(Infinity, def)).toEqual(NaN);
      expect(toImmutableDate(Infinity, { def })).toEqual(NaN);
      expect(toImmutableDate(-Infinity, def)).toEqual(NaN);
      expect(toImmutableDate(-Infinity, { def })).toEqual(NaN);
      expect(toImmutableDate(NaN, def)).toEqual(NaN);
      expect(toImmutableDate(NaN, { def })).toEqual(NaN);
      expect(toImmutableDate(Number.NaN, def)).toEqual(NaN);
      expect(toImmutableDate(Number.NaN, { def })).toEqual(NaN);
      expect(toImmutableDate({}, def)).toEqual(NaN);
      expect(toImmutableDate({}, { def })).toEqual(NaN);
      expect(toImmutableDate({ prop: 'not empty' }, def)).toEqual(NaN);
      expect(toImmutableDate({ prop: 'not empty' }, { def })).toEqual(NaN);
      expect(toImmutableDate(/regexp/, def)).toEqual(NaN);
      expect(toImmutableDate(/regexp/, { def })).toEqual(NaN);
      expect(toImmutableDate('', def)).toEqual(NaN);
      expect(toImmutableDate('', { def })).toEqual(NaN);
      expect(toImmutableDate('not empty', def)).toEqual(NaN);
      expect(toImmutableDate('not empty', { def })).toEqual(NaN);
      expect(toImmutableDate(null, def)).toEqual(NaN);
      expect(toImmutableDate(null, { def })).toEqual(NaN);
      expect(toImmutableDate(undefined, def)).toEqual(NaN);
      expect(toImmutableDate(undefined, { def })).toEqual(NaN);
    });

    it('called with an `ImmutableDate` instance input should return the `ImmutableDate` instance', () => {
      let input = new ImmutableDate(new Date());

      expect(toImmutableDate(input)).toBe(input);
      expect(toImmutableDate(input, null)).toBe(input);
      expect(toImmutableDate(input, { def: null })).toBe(input);
      expect(toImmutableDate(input, undefined)).toBe(input);
      expect(toImmutableDate(input, { def: undefined })).toBe(input);
    });

    it('called with date input should return an `ImmutableDate` instance representing the same date', () => {
      let input = new ImmutableDate(new Date(946684800000));

      expect(toImmutableDate(input)).toBe(input);
      expect(toImmutableDate(input, null)).toBe(input);
      expect(toImmutableDate(input, { def: null })).toBe(input);
      expect(toImmutableDate(input, undefined)).toBe(input);
      expect(toImmutableDate(input, { def: undefined })).toBe(input);
    });

    it('called with an object with a `toDate` function input should return an `ImmutableDate` instance representing the same date', () => {
      let input: any, output: any;

      input = new Date();
      output = toImmutableDate(input, {});
      expect(output.getTime()).toBe(input.getTime());

      input = { toDate: function () { return 946684800000; } };
      output = toImmutableDate(input);
      expect(output).toBeInstanceOf(ImmutableDate);
      expect(output.getTime()).toBe(946684800000);

      input = { toDate: function () { return new Date(946684800000); } };
      output = toImmutableDate(input);
      expect(output).toBeInstanceOf(ImmutableDate);
      expect(output.getTime()).toBe(946684800000);

      input = { toDate: function () { return new ImmutableDate(new Date(946684800000)); } };
      output = toImmutableDate(input);
      expect(output).toBeInstanceOf(ImmutableDate);
      expect(output.getTime()).toBe(946684800000);
    });

    it('called with a number input should return an `ImmutableDate` instance representing the same date', () => {
      let input: any, output: any;

      input = 946684800000;
      output = toImmutableDate(input);
      expect(output).toBeInstanceOf(ImmutableDate);
      expect(output.getTime()).toBe(946684800000);
    });

  });

  describe('`toImmutableDateOrNull`', () => {

    it('should be a function', () => {
      expect(typeof toImmutableDateOrNull).toBe('function');
    });

    it('called with no arguments should return `null`', () => {
      expect(toImmutableDateOrNull()).toBeNull();
    });

    it('called with inconvertible input should return `null`', function () {
      expect(toImmutableDateOrNull(arguments)).toBeNull();
      expect(toImmutableDateOrNull([])).toBeNull();
      expect(toImmutableDateOrNull(['not empty'])).toBeNull();
      expect(toImmutableDateOrNull(new Error('Help!'))).toBeNull();
      expect(toImmutableDateOrNull(function () {})).toBeNull();
      expect(toImmutableDateOrNull({})).toBeNull();
      expect(toImmutableDateOrNull({ prop: 'not empty' })).toBeNull();
      expect(toImmutableDateOrNull(null)).toBeNull();
      expect(toImmutableDateOrNull(NaN)).toBeNull();
      expect(toImmutableDateOrNull(Number.NaN)).toBeNull();
      expect(toImmutableDateOrNull(/regexp/)).toBeNull();
      expect(toImmutableDateOrNull('')).toBeNull();
      expect(toImmutableDateOrNull('not empty')).toBeNull();
      expect(toImmutableDateOrNull(undefined)).toBeNull();
    });

  });

});
